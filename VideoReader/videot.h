/*Workaround libavformat bug with c++*/
#ifndef INT64_C
#define INT64_C(c) (c ## LL)
#define UINT64_C(c) (c ## ULL)
#endif
//#include <windows.h>
extern "C" {
	#include <libavcodec/avcodec.h>
	#include <libavformat/avformat.h>
	#include <libswscale/swscale.h>
}
//CLASS FOR VIDEO HANDLING 

class videoReader
{
	private:
	AVCodecContext *pCodecCtx;
	AVFrame tmp_picture;
	AVFrame picture;
	AVFormatContext *pFormatCtx;
	int videoStream;
	AVOutputFormat *fmt;
	uint8_t *picture_buf;
	uint8_t *picture_buf2;
	std::vector<int64_t> tstamp;
	struct SwsContext *img_convert_ctx;
	AVPacket packet;
	AVCodec         *pCodec;
	int             numBytes;
	
	public:
	const char *filename;
	int frames,leveys,korkeus,varattu;
	unsigned char **video;

	//Class function declarations

	int lue_videota();
	int sulje_video();
	//Functions declared
	
	//Consructor, annetaan tiedosto ja montako framea halutaan lukea kerralla
	videoReader(const char* file, int fram)
	{
		av_register_all();	//Rekiströidään formaatit...
		filename = file;		//File to open
		frames = fram;	//Number of frames to be read
		varattu = frames;
		for (int lll = 0;lll<2;++lll){
			tstamp.push_back(0);
		}
		
		video = new unsigned char*[frames]; //Allocate memory
				
		// Open video file
		pFormatCtx = NULL;
		if(avformat_open_input(&pFormatCtx, filename, NULL, NULL)!=0){
			printf("Ei saanut filea auki\n");
			exit(1);
		}
					//return -1; // Couldn't open file
		// Retrieve stream information
		if(avformat_find_stream_info(pFormatCtx,NULL)<0){
			printf("Ei loytynyt streamia\n");
			exit(1);
		}
					//return -1; // Couldn't find stream information
	   // Dump information about file onto standard error
		av_dump_format(pFormatCtx, 0, filename, 0);
				// Find the first video stream
		videoStream=-1;
		for(int i=0; i<pFormatCtx->nb_streams; i++)
			if(pFormatCtx->streams[i]->codec->codec_type==AVMEDIA_TYPE_VIDEO)
			{
				videoStream=i;
				break;
			}
		if(videoStream==-1){
			printf("Ei loytynyt videostreamia\n");
			exit(1);
		}
			//return -1; // Didn't find a video stream
		// Get a pointer to the codec context for the video stream
		pCodecCtx=pFormatCtx->streams[videoStream]->codec;
		leveys = pCodecCtx->width;
		korkeus = pCodecCtx->height;
		//printf("Formaatti selvitetty\n");
		// Find the decoder for the video stream
		pCodec=avcodec_find_decoder(pCodecCtx->codec_id);
		if(pCodec==NULL){
			//return -1; // Codec not found
			printf("Ei koodekkia\n");
			}
		// Open codec
		if(avcodec_open2(pCodecCtx, pCodec,NULL)<0){
			//return -1; // Could not open codec
			printf("Koodekki ei auennut\n");
			}
			// Hack to correct wrong frame rates that seem to be generated by some codecs
		if(pCodecCtx->time_base.num>1000 && pCodecCtx->time_base.den==1)
			pCodecCtx->time_base.den=1000;
		// Allocate video frame
		 int size;
		tmp_picture=*(avcodec_alloc_frame());
		if (!&tmp_picture){
			//return 1;
			printf("Ei riittanyt muisti\n");
		}
		size = avpicture_get_size(pCodecCtx->pix_fmt, leveys, korkeus);
		picture_buf2 = (uint8_t*) av_malloc(size);
		if (!picture_buf2) {
			av_free(&tmp_picture);
			//return 1;
			printf("Ei muistia\n");
		}
		avpicture_fill((AVPicture *)&tmp_picture, picture_buf2,
					   pCodecCtx->pix_fmt, leveys, korkeus);
		

		
		//Allokoi paketti
		//av_allocpacket
		
		//Varaa muisti frameille...
		//printf("Varataan muisti\n");
		for (int i = 0;i< frames;i++){
			video[i] =  new unsigned char [leveys*korkeus];
			//printf("Varattu %d\r",i);
		
		}

		img_convert_ctx = NULL;
		if (pCodecCtx->pix_fmt != PIX_FMT_YUV420P) {
			printf("Eri pix_fmt\n");
			
			picture = *(avcodec_alloc_frame());
			if (!&picture){
				//return 1;
				printf("Ei kuvaa\n");
			}
			int size = avpicture_get_size(PIX_FMT_YUV420P, leveys, korkeus);
			picture_buf = (uint8_t*) av_malloc(size);
			if (!picture_buf) {
				av_free(&picture);
				//return 1;
				printf("Ei muistia kuvalle\n");
			}
			avpicture_fill((AVPicture *)&picture, picture_buf,
						   PIX_FMT_YUV420P, leveys, korkeus);
			
			/* as we only generate a YUV420P picture, we must convert it
			   to the codec pixel format if needed */
			if (img_convert_ctx == NULL) {
				//printf("Korkeus %d Leveys %d\n",pCodecCtx->height,pCodecCtx->width);
				img_convert_ctx = sws_getContext(pCodecCtx->width, pCodecCtx->height,
												 pCodecCtx->pix_fmt,
												 leveys, korkeus,
												 PIX_FMT_YUV420P
												 , SWS_BICUBIC, NULL, NULL, NULL);
			//printf("Kodek context valittu");
			//sws_getContext (int srcW, int srcH, int srcFormat, int dstW
			//, int dstH, int dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, double *param)
				if (img_convert_ctx == NULL) {
					fprintf(stderr, "Cannot initialize the conversion context\n");
					exit(1);
				}
			}
		}
	}
};

class videoWriter
{
	private:
		AVOutputFormat *fmt2;
		AVFormatContext *oc;
		AVStream *video_st;
		AVCodecContext *pCodecCtx2;
		AVCodec *pCodec;
		AVCodecContext *pContext;
		//AVDictionary* avDictOpts;
		
		uint8_t *video_outbuf;
		uint8_t *picture_buf3;
		uint8_t *picture_buf2;
		int video_outbuf_size;
		const char* filename;
		AVFrame *picture3;
		int uleveys, ukorkeus,framesEncoded;
		struct SwsContext *img_convert_ctx;
	public:
		
		AVFrame *tmp_picture2;
	//Function declarations
		int valmistele();
		void write_video_frame();
		void write_trailer();
		videoWriter(const char* fname, int lev, int kor) //Constructor
		{
				uleveys = lev;
				ukorkeus = kor;
				framesEncoded = 0;
				img_convert_ctx = NULL;
				filename = fname;
				printf("Tulosvideon nimi %s\n",filename);
				av_register_all();	//Rekisteröidään formaatit...
				//avcodec_register_all();	//Rekisteröidään koodekit
				printf("Registered_all\n");
				// allocate the output media context 
				avformat_alloc_output_context2(&oc,NULL, NULL, filename);
				if (!oc){
					printf("Couldn't alloc context\n");
					exit(1);
				}
				/*set output format*/
				fmt2 = oc->oformat;
				fmt2->video_codec = AV_CODEC_ID_H264;//AV_CODEC_ID_MPEG1VIDEO;//AV_CODEC_ID_MJPEG;//
				/* add the video stream*/
				video_st = NULL;
				printf("video_codec %d\n",(int) fmt2->video_codec);
				 if (fmt2->video_codec != CODEC_ID_NONE) {
					/*GET X264codec*/
					pCodec =  avcodec_find_encoder(fmt2->video_codec);
					if (!pCodec) {
						fprintf(stderr, "Codec not found\n");
						exit(1);
					}
					printf("found encoder\n");
				 
					video_st = avformat_new_stream(oc, pCodec);
					if (!video_st) {
						fprintf(stderr, "Could not alloc stream\n");
						exit(1);
					}
					video_st->id = oc->nb_streams-1;
					pContext = video_st->codec;
					/* Adjust sample parameters */
					pContext->bit_rate = 1000000;
					/* resolution must be a multiple of two */
					pContext->width = uleveys;
					pContext->height = ukorkeus;
					/* frames per second */
					pContext->time_base= (AVRational){1,25};
					pContext->gop_size = 10; /* emit one intra frame every ten frames */
					pContext->max_b_frames=1;
					pContext->pix_fmt = AV_PIX_FMT_YUV420P;
					pContext->profile = FF_PROFILE_H264_BASELINE;
					pContext->flags |= AVFMT_ALLOW_FLUSH; //Try to allow flushing for x264
					printf("adjusted options\n");
					// some formats want stream headers to be separate
					if(oc->oformat->flags & AVFMT_GLOBALHEADER){
						video_st->codec->flags |= CODEC_FLAG_GLOBAL_HEADER;
					}
					printf("Streami lisatty\n");
				}
				
				/* open codec */
				printf("Open codec\n");
				if (avcodec_open2(pContext, pCodec, NULL) < 0) {
					fprintf(stderr, "Could not open codec\n");
					exit(1);
				}
				printf("Opened codec %d\n",pContext->codec->id);	
				
				printf("Dump format\n");
				av_dump_format(oc, 0, filename, 1);
				/* open the output file */
				if (!(fmt2->flags & AVFMT_NOFILE)) {
					int ret = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE);
					if (ret < 0) {
						printf("Could not open '%s\n", filename);
						exit(1);
					}
				}
				printf("Header kirjoittamaan\n");	
				/* write the stream header, if any */
				avformat_write_header(oc,NULL);
				pCodecCtx2 = video_st->codec;
				int size;
				printf("Kuvia allocoimaan %d %d\n", pCodecCtx2->width, pCodecCtx2->height);
				tmp_picture2=avcodec_alloc_frame();
				if (!tmp_picture2)
					printf("Ei kuvaa\n");
					
				size = avpicture_get_size(pCodecCtx2->pix_fmt, pCodecCtx2->width, pCodecCtx2->height);
				picture_buf2 = (uint8_t*) av_malloc(size);
				if (!picture_buf2) {
					av_free(tmp_picture2);
					printf("Ei bufferia\n");
				}
				avpicture_fill((AVPicture *)tmp_picture2, picture_buf2,
							pCodecCtx2->pix_fmt, pCodecCtx2->width, pCodecCtx2->height);
				
				//Säädetään kuva mustavalkoiseksi..
				printf("Memsettiin\n");
				memset(tmp_picture2->data[1],128,uleveys*ukorkeus/4);
				memset(tmp_picture2->data[2],128,uleveys*ukorkeus/4);
				  
				picture3 = avcodec_alloc_frame();
				
				if (!picture3)
					printf("Ei kuvaa\n");
				size = avpicture_get_size(PIX_FMT_YUV420P, uleveys, ukorkeus);
				picture_buf3 = (uint8_t*) av_malloc(size);
				if (!picture_buf3) {
					av_free(picture3);
					printf("Ei bufferia\n");
				}
				avpicture_fill((AVPicture *)picture3, picture_buf3,
							   PIX_FMT_YUV420P, uleveys, ukorkeus);
				picture3->pts = 0;
				printf("Picture allocoitu\n");
				printf("Ulos lev %d kor %d\n",pCodecCtx2->width,pCodecCtx2->height);
		}
};

int videoReader::lue_videota(){
    //av_free_packet(&packet);	
	
	int frameja2 = 0;
	int frameFinished;
	//Seeking (did not work well...) POIS KÄYTÖSTÄ
	
	//printf("\nfmtTstamp %ld\n",tstamp);
	
	if (tstamp[0] != 0){ //Käytetään seek framea, jotta saadaan kokonaisia kuvia...
		printf("\nSeek\n");
		int64_t kohta = tstamp[2];
		printf("Tstamp ennen etsintaa %ld\n",tstamp[0]);
		int onnistui = av_seek_frame(pFormatCtx,videoStream,tstamp[2],AVSEEK_FLAG_BACKWARD);
		//printf("Tstamp etsinnan jalkeen %ld fmt %ld\n",packet.pts,*(pFormatCtx->streams[videoStream]).cur_dts);
		if (onnistui < 0){
			printf("Etsinta epaonnistui %d\n",onnistui);
			return 1;
		}
		bool viela = true;
		while (viela){
			av_read_frame( pFormatCtx, &packet );
			if(packet.stream_index==videoStream)
			{
				avcodec_decode_video2(pCodecCtx, &tmp_picture, &frameFinished, 
                &packet);
				kohta = packet.pts;
				//printf("Tstamp etsinnan aikana %ld\n",kohta);
				if (kohta == tstamp[0]){
					viela = false;
				}
			}
			
			av_free_packet( &packet );
		}
		 printf("Tstamp etsinnan lopuksi %ld packet %ld\n",kohta,packet.pts);
		 //Luetaan vielä yksi bonus frame...
    }
	
	//printf("LukuWhileen\n");
	//cimg_library::CImgDisplay pkuva1(leveys,korkeus,"Pkuva1",0,false,true);
	
	//pkuva1.move(0,20);
    while(av_read_frame(pFormatCtx, &packet)>=0 && frameja2 < frames )
    {
        if(packet.stream_index==videoStream)		 // Is this a packet from the video stream?
        {
			//printf("Dekoodaamaan\n");
            avcodec_decode_video2(pCodecCtx, &tmp_picture, &frameFinished, &packet);            // Decode video frame
			//printf("Dekoodattiin\n");
            if(frameFinished)	            // Did we get a video frame?
            {
				if(img_convert_ctx == NULL){
					//printf("Memcpy, ei skaalausta\n");
					if (tmp_picture.linesize[0] != leveys){ //Hack for padding
						for (int zzz = 0; zzz < korkeus;zzz++){
							memcpy(video[frameja2]+zzz*leveys,tmp_picture.data[0]+zzz*tmp_picture.linesize[0],leveys*sizeof(unsigned char));
						}
					} else {
						memcpy(video[frameja2],tmp_picture.data[0],leveys*korkeus*sizeof(unsigned char));
					}
				}else{//If pixel_fmt is not YUV_420P
					//printf("Memcpy ja skaalaus\n");
					sws_scale(img_convert_ctx, tmp_picture.data, tmp_picture.linesize,
                      0, korkeus, picture.data, picture.linesize);
					//printf("Skaalaus onnistui\n");
					
					if (picture.linesize[0] != leveys){//Hack for padding (probably not needed...
						printf("memcpy hack\n");
						for (int zzz = 0; zzz < korkeus;zzz++){
							memcpy(video[frameja2]+zzz*leveys,picture.data[0]+zzz*tmp_picture.linesize[0],leveys*sizeof(unsigned char));
						}
					} else {
						//printf("No hack\n");	
						memcpy(video[frameja2],picture.data[0],leveys*korkeus*sizeof(unsigned char));
					}
					//printf("memcpy onnistui\n");
				}
				/*
				cimg_library::CImg<unsigned char> testi(leveys,korkeus,1,1,0);
				memcpy(testi,video[frameja2],leveys*korkeus*sizeof(unsigned char));
				pkuva1.display(testi);
				pkuva1.wait();
				*/
				frameja2++;
				tstamp.insert(tstamp.begin(),packet.pts);
				tstamp.pop_back();
			}
        }
        // Free the packet that was allocated by av_read_frame
        av_free_packet(&packet);
    }
	printf("\nViimeinen %ld\n",packet.pts);
	frames = frameja2;
}

int videoReader::sulje_video(){
    
	//printf("Kuvat luettu\n");
	//av_free(&tmp_picture);
	//av_free(&picture);
	
    // Close the codec
    avcodec_close(pCodecCtx);
// Close the video file
    avformat_close_input(&pFormatCtx);
	//Free memory
	delete [] video;
	video = NULL;

}



void videoWriter::write_video_frame()
{
	
    int out_size, ret;
    AVCodecContext *c;

    c = video_st->codec;
	double pts = (double)video_st->pts.val * video_st->time_base.num /video_st->time_base.den;
	if (pCodecCtx2->pix_fmt != PIX_FMT_YUV420P || c->width != uleveys || c->height != ukorkeus) {
        
            /* as we only generate a YUV420P picture, we must convert it
               to the codec pixel format if needed */
			   
            if (img_convert_ctx == NULL) {
				//printf("Korkeus %d Leveys %d\n",pCodecCtx->height,pCodecCtx->width);
                img_convert_ctx = sws_getContext(pCodecCtx2->width, pCodecCtx2->height,
                                                 pCodecCtx2->pix_fmt,
                                                 c->width, c->height,
                                                 c->pix_fmt
                                                 , SWS_BICUBIC, NULL, NULL, NULL);
			//printf("Kodek context valittu");
			//sws_getContext (int srcW, int srcH, int srcFormat, int dstW
			//, int dstH, int dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, double *param)
												 
                if (img_convert_ctx == NULL) {
                    fprintf(stderr, "Cannot initialize the conversion context\n");
                    exit(1);
                }
            }
            sws_scale(img_convert_ctx, tmp_picture2->data, tmp_picture2->linesize,
                      0, c->height, picture3->data, picture3->linesize);
				
				

        } else {
			avpicture_fill((AVPicture *)picture3, tmp_picture2->data[0], c->pix_fmt,
				c->width, c->height);
		}
    
	/*Try to show the image*/
	/*
	cimg_library::CImgDisplay pkuva1(c->width,c->height,"Pkuva1",0,false,true);
	pkuva1.move(0,20);
	cimg_library::CImg<unsigned char> testi(c->width,c->height,1,1,0);
	memcpy(testi,picture3->data[0],c->width*c->height*sizeof(unsigned char));
	pkuva1.display(testi);
	pkuva1.wait();
	*/
	/* encode the image */
	AVPacket pkt = { 0 };
	av_init_packet(&pkt);
	int got_output;
	out_size = avcodec_encode_video2(c, &pkt, picture3, &got_output);
	printf("oSize %d gPut %d\n",out_size,got_output);
	if (!out_size && got_output && pkt.size) {
		pkt.stream_index = video_st->index;

		/* Write the compressed frame to the media file. */
		ret = av_interleaved_write_frame(oc, &pkt);
		//printf("Wrote interleaved frame %d\n",ret);
	} else {
		ret = 0;
	}
	picture3->pts += av_rescale_q(1, video_st->codec->time_base, video_st->time_base);
	++framesEncoded;

    if (ret != 0) {
        fprintf(stderr, "Error while writing video frame\n");
        exit(1);
    }

    
}

void videoWriter::write_trailer(){
	/*Get the delayed frames*/
    AVCodecContext *c;
    c = video_st->codec;
	int ret,out_size;
	// encode the image 
	int64_t pts = picture3->pts;
	
	int got_output;
	printf("Flushing\n");
	while (1){
		AVPacket pkt = { 0 };
	av_init_packet(&pkt);
	//for (int i = 0; i<10; ++i){
		out_size = avcodec_encode_video2(c, &pkt, NULL, &got_output);
		printf("Flushing oSize %d gPut %d\n",out_size,got_output);
		if (!out_size && got_output && pkt.size) {
			pkt.stream_index = video_st->index;
			pkt.pts = pts;
			pts+=av_rescale_q(1, video_st->codec->time_base, video_st->time_base);
			// Write the compressed frame to the media file. 
			ret = av_interleaved_write_frame(oc, &pkt);
			//printf("Wrote interleaved frame %d\n",ret);
		} else {
			ret = 0;
			if (got_output < 1){
				break;
			}
		}
	}
	
	av_write_trailer(oc);
	avio_close(oc->pb);// Close the output file. 
	/*
    if (video_st){
		avcodec_close(video_st->codec);
		//av_free(picture3->data);
	}
    if (!(fmt2->flags & AVFMT_NOFILE)){
        avio_close(oc->pb);// Close the output file. 
	}
    // free the stream /
    avformat_free_context(oc);
	*/
}
